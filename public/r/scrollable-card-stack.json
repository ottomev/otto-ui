{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scrollable-card-stack",
  "type": "registry:ui",
  "dependencies": [
    "motion",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "utils/cn.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/cn.ts"
    },
    {
      "path": "ottoui/ScrollableCardStack.tsx",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { motion, useMotionValue, useSpring } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils/cn\"\n\ninterface CardItem {\n  id: string\n  name: string\n  handle: string\n  avatar: string\n  video: string\n  href: string\n}\n\ninterface ScrollableCardStackProps {\n  items: CardItem[]\n  cardHeight?: number\n  perspective?: number\n  transitionDuration?: number\n  className?: string\n}\n\nconst ScrollableCardStack: React.FC<ScrollableCardStackProps> = ({\n  items,\n  cardHeight = 384,\n  perspective = 1000,\n  transitionDuration = 180,\n  className,\n}) => {\n  const [currentIndex, setCurrentIndex] = useState(0)\n  const [isDragging, setIsDragging] = useState(false)\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null)\n  const [isScrolling, setIsScrolling] = useState(false)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const scrollY = useMotionValue(0)\n  const lastScrollTime = useRef(0)\n\n  // Improved spring config inspired by the reference code\n  const springConfig = {\n    damping: 20,\n    stiffness: 250,\n    mass: 0.5,\n  }\n\n  // Calculate the total number of items\n  const totalItems = items.length\n  const maxIndex = totalItems - 1\n\n  // Spring-based scroll for smooth animations\n  const springScrollY = useSpring(scrollY, springConfig)\n\n  // Constants for visual effects - matching reference code exactly\n  const FRAME_OFFSET = -30\n  const FRAMES_VISIBLE_LENGTH = 3\n  const SNAP_DISTANCE = 50\n\n  // Clamp function from reference code - memoized to prevent recreation\n  const clamp = useCallback(\n    (val: number, [min, max]: [number, number]): number => {\n      return Math.min(Math.max(val, min), max)\n    },\n    []\n  )\n\n  // Controlled scroll function to move exactly one card\n  const scrollToCard = useCallback(\n    (direction: 1 | -1) => {\n      if (isScrolling) return\n\n      const now = Date.now()\n      const timeSinceLastScroll = now - lastScrollTime.current\n      const minScrollInterval = 300\n\n      if (timeSinceLastScroll < minScrollInterval) {\n        return\n      }\n\n      const newIndex = clamp(currentIndex + direction, [0, maxIndex])\n\n      if (newIndex !== currentIndex) {\n        lastScrollTime.current = now\n        setIsScrolling(true)\n        setCurrentIndex(newIndex)\n        scrollY.set(newIndex * SNAP_DISTANCE)\n\n        setTimeout(() => {\n          setIsScrolling(false)\n        }, transitionDuration + 100)\n      }\n    },\n    [currentIndex, maxIndex, scrollY, isScrolling, transitionDuration, clamp]\n  )\n\n  // Handle scroll events with improved responsiveness\n  const handleScroll = useCallback(\n    (deltaY: number) => {\n      if (isDragging || isScrolling) return\n\n      const minScrollThreshold = 20\n      if (Math.abs(deltaY) < minScrollThreshold) {\n        return\n      }\n\n      const scrollDirection = deltaY > 0 ? 1 : -1\n      scrollToCard(scrollDirection)\n    },\n    [isDragging, isScrolling, scrollToCard]\n  )\n\n  // Handle wheel events\n  const handleWheel = useCallback(\n    (e: WheelEvent) => {\n      e.preventDefault()\n      handleScroll(e.deltaY)\n    },\n    [handleScroll]\n  )\n\n  // Handle keyboard navigation - improved with reference code logic\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (isScrolling) return\n\n      switch (e.key) {\n        case \"ArrowUp\":\n        case \"ArrowLeft\":\n          e.preventDefault()\n          scrollToCard(-1)\n          break\n        case \"ArrowDown\":\n        case \"ArrowRight\":\n          e.preventDefault()\n          scrollToCard(1)\n          break\n        case \"Home\":\n          e.preventDefault()\n          if (currentIndex !== 0) {\n            setIsScrolling(true)\n            setCurrentIndex(0)\n            scrollY.set(0)\n            setTimeout(() => setIsScrolling(false), transitionDuration + 100)\n          }\n          break\n        case \"End\":\n          e.preventDefault()\n          if (currentIndex !== maxIndex) {\n            setIsScrolling(true)\n            setCurrentIndex(maxIndex)\n            scrollY.set(maxIndex * SNAP_DISTANCE)\n            setTimeout(() => setIsScrolling(false), transitionDuration + 100)\n          }\n          break\n      }\n    },\n    [\n      currentIndex,\n      maxIndex,\n      scrollY,\n      isScrolling,\n      scrollToCard,\n      transitionDuration,\n    ]\n  )\n\n  // Handle touch events for mobile\n  const touchStartY = useRef(0)\n  const touchStartIndex = useRef(0)\n  const touchStartTime = useRef(0)\n  const touchMoved = useRef(false)\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      touchStartY.current = e.touches[0].clientY\n      touchStartIndex.current = currentIndex\n      touchStartTime.current = Date.now()\n      touchMoved.current = false\n      setIsDragging(true)\n    },\n    [currentIndex]\n  )\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent) => {\n      if (!isDragging || isScrolling) return\n\n      const touchY = e.touches[0].clientY\n      const deltaY = touchStartY.current - touchY\n      const scrollThreshold = 100\n\n      if (Math.abs(deltaY) > scrollThreshold && !touchMoved.current) {\n        const scrollDirection = deltaY > 0 ? 1 : -1\n        scrollToCard(scrollDirection)\n        touchMoved.current = true\n      }\n    },\n    [isDragging, isScrolling, scrollToCard]\n  )\n\n  const handleTouchEnd = useCallback(() => {\n    setIsDragging(false)\n    touchMoved.current = false\n  }, [])\n\n  // Set up event listeners\n  useEffect(() => {\n    const container = containerRef.current\n    if (!container) return\n\n    container.addEventListener(\"wheel\", handleWheel, { passive: false })\n\n    return () => {\n      container.removeEventListener(\"wheel\", handleWheel)\n    }\n  }, [handleWheel])\n\n  // Snap to current index when not dragging\n  useEffect(() => {\n    if (!isDragging) {\n      scrollY.set(currentIndex * SNAP_DISTANCE)\n    }\n  }, [currentIndex, isDragging, scrollY])\n\n  // Calculate transform for each card based on the reference code\n  const getCardTransform = useCallback(\n    (index: number) => {\n      const offsetIndex = index - currentIndex\n      const absOffsetIndex = Math.abs(offsetIndex)\n\n      // Apply blur effect for cards behind the current one - matching reference exactly\n      const blur = currentIndex > index ? 2 : 0\n\n      // Opacity based on distance - improved logic from reference\n      const opacity = currentIndex > index ? 0 : 1\n\n      // Scale with improved calculation inspired by reference - using clamp function\n      const scale = clamp(1 - offsetIndex * 0.08, [0.08, 2])\n\n      // Vertical offset with improved calculation - matching reference exactly\n      const y = clamp(offsetIndex * FRAME_OFFSET, [\n        FRAME_OFFSET * FRAMES_VISIBLE_LENGTH,\n        Infinity,\n      ])\n\n      // Z-index for proper layering - matching reference pattern\n      const zIndex = items.length - index\n\n      return {\n        y,\n        scale,\n        opacity,\n        blur,\n        zIndex,\n      }\n    },\n    [currentIndex, items.length, clamp]\n  )\n\n  return (\n    <section\n      ref={containerRef}\n      className={cn(\n        \"relative mx-auto h-fit min-h-[200px] w-fit min-w-[300px]\",\n        className\n      )}\n      style={{\n        perspective: `${perspective}px`,\n        perspectiveOrigin: \"center 60%\",\n        touchAction: \"none\",\n      }}\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n      onKeyDown={handleKeyDown}\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      aria-label=\"Scrollable card stack\"\n    >\n      {items.map((item, i) => {\n        const transform = getCardTransform(i)\n        const isActive = i === currentIndex\n        const isHovered = hoveredIndex === i\n\n        return (\n          <motion.div\n            key={`scrollable-card-${item.id}`}\n            className=\"bg-background absolute top-1/2 left-1/2 h-max w-max max-w-[100vw] overflow-hidden rounded-2xl border shadow-lg\"\n            data-active={isActive}\n            style={{\n              zIndex: transform.zIndex,\n              pointerEvents: isActive ? \"auto\" : \"none\",\n              transformOrigin: \"center center\",\n              willChange: \"opacity, filter, transform\",\n              filter: `blur(${transform.blur}px)`,\n              opacity: transform.opacity,\n              transitionProperty: \"opacity, filter\",\n              transitionDuration: \"200ms\",\n              transitionTimingFunction: \"ease-in-out\",\n              // Dynamic border width based on scale - from reference code\n              borderWidth: `${2 / transform.scale}px`,\n            }}\n            initial={false}\n            animate={{\n              y: `calc(-50% + ${transform.y}px)`,\n              scale: transform.scale,\n              x: \"-50%\",\n            }}\n            whileHover={\n              isActive\n                ? {\n                    scale: transform.scale * 1.02,\n                    transition: {\n                      type: \"spring\",\n                      stiffness: 250,\n                      damping: 20,\n                      mass: 0.5,\n                    },\n                  }\n                : {}\n            }\n            transition={{\n              type: \"spring\",\n              stiffness: 250,\n              damping: 20,\n              mass: 0.5,\n            }}\n            aria-hidden={!isActive}\n            tabIndex={isActive ? 0 : -1}\n            onMouseEnter={() => isActive && setHoveredIndex(i)}\n            onMouseLeave={() => setHoveredIndex(null)}\n            onFocus={() => isActive && setHoveredIndex(i)}\n            onBlur={() => setHoveredIndex(null)}\n          >\n            {/* Card Content */}\n            <div\n              className={cn(\n                \"bg-background flex h-fit w-96 flex-col items-center rounded-xl transition-all duration-200\",\n                isHovered && \"shadow-xl\",\n                isScrolling && isActive && \"ring-opacity-50 ring-brand ring-2\"\n              )}\n            >\n              {/* Scroll indicator */}\n              {isScrolling && isActive && (\n                <div className=\"absolute -top-1 left-1/2 h-1 w-8 -translate-x-1/2 rounded-full bg-blue-200 opacity-75\" />\n              )}\n\n              {/* Video Container */}\n              <div\n                className=\"relative w-full overflow-hidden\"\n                style={{ aspectRatio: \"1.77778 / 1\" }}\n              >\n                {/* Background blur image */}\n                <img\n                  aria-hidden=\"true\"\n                  alt=\"\"\n                  decoding=\"async\"\n                  src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwIiBoZWlnaHQ9IjEwIiBmaWxsPSIjZjNmNGY2Ii8+PC9zdmc+\"\n                  className=\"absolute inset-0 h-full w-full object-cover text-transparent\"\n                  style={{\n                    filter: \"blur(32px)\",\n                    scale: \"1.2\",\n                    zIndex: 1,\n                    pointerEvents: \"none\",\n                  }}\n                />\n                {/* Video */}\n                <video\n                  autoPlay\n                  loop\n                  playsInline\n                  muted\n                  src={item.video}\n                  className=\"absolute inset-0 h-full w-full object-cover\"\n                  style={{ zIndex: 2 }}\n                />\n              </div>\n\n              {/* Header */}\n              <a\n                className={cn(\n                  \"text-decoration-none flex items-center gap-1 p-3 text-inherit transition-colors duration-200\"\n                )}\n                href={item.href}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                aria-label={`View ${item.name}'s profile`}\n              >\n                <img\n                  className=\"mr-1 h-5 w-5 overflow-hidden rounded-full\"\n                  alt={`${item.name}'s avatar`}\n                  width={20}\n                  height={20}\n                  src={item.avatar}\n                  style={{\n                    boxShadow: \"0 0 0 1px var(--border-secondary, #e0e0e0)\",\n                  }}\n                />\n                <span className=\"text-foreground text-sm leading-none font-medium\">\n                  {item.name}\n                </span>\n                <span className=\"text-foreground/70 text-sm font-normal\">\n                  {item.handle}\n                </span>\n              </a>\n            </div>\n          </motion.div>\n        )\n      })}\n\n      {/* Navigation indicators */}\n      <div\n        className=\"absolute bottom-4 left-1/2 flex -translate-x-1/2 transform space-x-2\"\n        role=\"tablist\"\n        aria-label=\"Card navigation\"\n      >\n        {Array.from({ length: items.length }, (_, i) => {\n          return (\n            <motion.button\n              key={`scrollable-indicator-${items[i]?.id || i}`}\n              type=\"button\"\n              onClick={() => {\n                if (i !== currentIndex && !isScrolling) {\n                  setIsScrolling(true)\n                  setCurrentIndex(i)\n                  scrollY.set(i * SNAP_DISTANCE)\n                  setTimeout(\n                    () => setIsScrolling(false),\n                    transitionDuration + 100\n                  )\n                }\n              }}\n              className={cn(\n                \"h-2 w-2 rounded-full transition-all duration-200 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:outline-none\",\n                i === currentIndex\n                  ? \"scale-125 bg-blue-500\"\n                  : \"bg-gray-300 hover:bg-gray-400\"\n              )}\n              whileHover={{ scale: 1.2 }}\n              whileTap={{ scale: 0.9 }}\n              transition={{\n                type: \"spring\",\n                stiffness: 250,\n                damping: 20,\n                mass: 0.5,\n              }}\n              role=\"tab\"\n              aria-selected={i === currentIndex}\n              aria-label={`Go to card ${i + 1} of ${items.length}`}\n            />\n          )\n        })}\n      </div>\n\n      {/* Instructions for screen readers */}\n      <div className=\"sr-only\" aria-live=\"polite\">\n        {`Card ${currentIndex + 1} of ${items.length} selected. Use arrow keys to navigate one card at a time, or click the dots below.`}\n      </div>\n    </section>\n  )\n}\n\nexport default ScrollableCardStack\n",
      "type": "registry:ui",
      "target": "components/ottoui/ui/ScrollableCardStack.tsx"
    }
  ]
}